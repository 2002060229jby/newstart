## 直接查看汇编代码

```shell
g++ -help
gcc 0.reference.cpp -S
ls
vim 0.reference.s

:vsplit
:e 0.reference.cpp
```

.LFB971表示函数的入口

局部变量在内存的**栈段**

- 栈段用到哪里了呢？

我们压栈出栈最重要的是操作**栈顶**（记录栈用到哪了）

- SP指针就是栈顶指针。

栈是从高地址用到地地址。

- bp就是基址寄存器

基址加上偏移量就能访问到一块内存

- rax临时寄存器

```
pushq %rbp  保护线程
popq %rbp   释放线程

movq 是把内存里存的值丢过去
leaq 是把内存的地址丢过去
```

我们不能同时读写内存，这也是临时寄存器存在的意义。

%eax存放返回值的寄存器（%rax）表示访问里面的内存

![image-20220711163239158](C:\Users\adam\AppData\Roaming\Typora\typora-user-images\image-20220711163239158.png)

## 如何理解引用

**引用**有点像文件的**硬链接**

给变量取一个别名，底层实现还是用指针。语法糖。

## define 和typedef的区别

define，宏定义在预处理阶段就会被替换掉。

typedef 是给类型起别名。

## 常量存放在哪

常量存在代码段，所以**常引用**实际上是开辟了一块空间来存放代码段里的一条指令里的一个**常量**。

## 类=数+操作（数据结构）

- **概念：**
  - 类和对象
  - 成员属性和方法
  - 访问权限
    - public
    - private
    - protected

## 声明和定义是不一样的。

`collect2: error: ld returned 1 exit status`是在链接阶段报的错误。

`undefined reference to Washer::getBrand()'`

有人不见了。只声明未定义。



## this指针

调用这个函数的对象的地址指针，会悄悄地传给成员函数/方法.

## gdb调试

```shell
g++ 4.reference.cpp -g
gdb a.out
l  查看多行
b main 打断点
r  运行程序
n  运行下一行
s  进入到函数里面
p this  打印变量  
#$1 = (Washer * const) 0x0 #const说明this指针不能改变指向
q 退出 y确定
```

## 命名空间

```c++
namespace kkb{
	
}
using namespace kkb; //kkb中的所有内容都导入过来。尽量不使用这个。

//工程里这样子干
#define BEGINS(x) namespace x{
#define ENDS(x) }
BEGINS(kkb)

ENDS(kkb)
```

就像一个局域网。

## 实现一个cout(d2)

cout是一个对象

<<是一个操作

## 对象的诞生和终结

构造函数：（初始化）

- 默认构造
- 转换构造
- 拷贝构造

析构函数：（释放）

> 无参拷贝析构函数，默认都给你写好了。

**先构造的东西后析构，先定义的东西先构造。**

- 局部变量在栈段。但是即便放在全局变量里也是这样
- 为了防止后面的变量依赖前面的变量。所以统一规定这样的顺序。

**工程上申请大块内存的时候，通常不在构造函数里申请。**后面异常处理不方便（伪构造和析构）

**拷贝构造时候参数最好const**

#### **当你在定义的时候=等价于拷贝构造。其他的情况就是赋值。**

## 转换构造

访问变量遵循**就近原则**。

编译器在比较的时候会把等式两边转化成相同类型。一般长度低的向长度高的转化（缺位补零），更安全，编译器也是这么做的。

计算机中存的是**补码**。

- 第一步生成**匿名对象**
- 进行赋值操作。

## 拷贝构造为什么要传引用

拷贝构造是拿同类对象进行初始化。

默认实参对形参进行初始化/构造。即**拷贝构造**。但是我拷贝构造都没定义好呢，这样就变成一个**无限循环**游戏了。

**传引用**，拿已经初始化好的变量。

**函数调用**在干什么，是在拿**实参对形参进行初始化。**

## 初始化不等于赋值。

- 初始化和构造在是一起的。用的是c++里的**初始化器**而**赋值就是=**，比如你不能对一个const类型的变量赋值。而只能对他初始化。

```c++
const A a;
a=100;
```

- 为了防止100的匿名对象在赋值的过程中会对a的属性有所修改，在重载的时候就得加上const,不光函数体，还包括返回值

所以我们要用**初始化列表**，且先定义的谁，先初始化谁。

## 堆和栈

堆和栈在运行时才有，而代码段，数据段（全局变量）在编译时就有。



## 默认的拷贝构造会导致的问题

**默认是个浅拷贝**。因为涉及到指针会被原模原样地拷贝过去。所以十分不安全。还可能导致double free

不像深拷贝那样重新开辟一块指针所指的空间并拷贝过去。

所以我们需要自己定义拷贝构造。



## 逻辑上的构造，空间

1. 程序到第几行完成了逻辑上的构造
   - 构造函数结束，就完成了

2. 程序到第几行类的对象就已经有空间了，但还没初始化
   - 在我还没初始化的时候，构造函数之前，这块空间就已经有了

## new和malloc的区别

new会默认调用构造。包括delete会默认调用析构。

而malloc 就不会。

小技巧：malloc之后，可以再调用new进行**原地构造**。（甚至可以拿另外一个类的构造进行初始化）

栈段的地址通常比较大，从大到小的用。栈段和堆段相隔甚远。

## static修饰类属性、类方法

## class 访问权限默认为private

## RVO返回值优化

```c++
A func(){
    A tmp(100);
    return tmp;
}
int main(){
    A a=func();

    return 0;
}
```

1. tmp返回值对匿名对象进行拷贝
2. 匿名对象对a进行拷贝

但实际上只进行了一次转换构造，并没有拷贝构造。

查看**tmp的地址和a的地址相同**，所以直接**引用**了。

```
g++ 0.rvo.cpp -S
```

di寄存器，si寄存器，传参用的

call调用函数

r 64位，e 32位

a不断地往里死命传，是的tmp看起来就像a的引用一样，再调用构造函数的时候，这个this指针就是a的地址。

**别优化：**

```shell
g++ 0.rvo.cpp -fno-elide-constructors
```

**为什么不能传引用？**

- 因为tmp会被销毁。

###### **所以不要改变拷贝构造的语义，不然会根据编译选项的不同产生不同的结果**

## 声明和定义的区别

类内声明，类外定义。初始化得和定义放在一起

## 看目标文件

```shell
g++ 1.static.cpp -c
nm 1.static.o

D表示.data段 全局变量都在.data段
B表示.bss段
U表示没实现
T t表示代码段
```

## mutable

const对象只能调const方法，除非你用mutable修饰变量

## c++支持同名函数参数不同

只和参数列表有关，和返回值无关，

c++还有传默认参的方式：必须放参数列表最后

## 编译和链接

函数定义可能压根就不在我当前文件中实现。具体实现在什么位置由连接器你去找

```shell
g++ add.cpp -c
g++ main.cpp -o
nm add.o
g++ add.o main.o  #链接生成./a.out可执行程序
```

## delete 和default

default是系统默认创造好的构造。

delete是不使用系统构造。

**默认的析构是什么也不干**

## 友元

```c++
friend void useOtehrsMoney(People &a);
```

类外成员想要访问类中成员得要获得类中引用或指针。

## ++i和i++

++i可以作为左值，表示那块内存。

而i++不行。在汇编层，++i效率更高，只有一行代码。i++有两行。

++i是**原子操作**。

## ->*

```c++
#include <iostream>
using namespace std;
class A{
public:
    void output(){
        cout<<"hello"<<endl;
    }
};

int main(){
    A a;
    A *k=&a;
    void (A::*p)() = &A::output;
    (k->*p)();
    (a.*p)();
    return 0;
}
```

不能重载的运算符：

- sizeof也是运算符，但不能重载。
- ::（域运算符）
- .*
- .
- ?:(三目运算符)

## 委托构造

```c++
// Point::point():x(0),y(0){}
Point::Point():Point(0,0){}
Point::Point(int m,int n):x(m),y(n){}
```

